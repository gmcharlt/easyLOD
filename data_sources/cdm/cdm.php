<?php

/**
 * Data source plugin for easyLOD that generates XML for an item in CONTENTdm.
 * Issues a query to CONTENTdm's web API to get all the metadata for the item
 * but only returns fields that are mapped to Dublin Core in the collection.
 *
 * Distributed under the MIT License, http://opensource.org/licenses/MIT.
 */

/**
 * Required function. Checks to see if a configuration for this plugin
 * exists in the $plugins array, and if not, returns the configuration
 * defined here.
 *
 * @param string $namespace
 *  The namespace portion of the request URI.
 *
 * @return
 *  An associative array containing this plugin's configuration data
 *  in key => value pairs.
 */
function dataSourceConfig($namespace) {
  // First check to see if this configration is being
  // overridden in plugins.php.
  global $plugins;
  if (array_key_exists($namespace, $plugins)) {
    return $plugins[$namespace]['dataSourceConfig'];
  }
  // If the configuration is not being overridden, use
  // this one.
  else {
    return array(
      // URL of the CONTENTdm web services API.
      'ws_url' => 'http://contentdm.library.ca:81/dmwebservices/index.php?q=',
      // URL of the public interface to CONTENTdm; used in generating direct URLs
      // to item-level records.
      'contentdm_base_url' => 'http://contentdm.library.ca/cdm/ref/collection/',
    );
  }
}

/**
 * Required function. Defines the XML namespace that the elements
 * generated by this plugin belong to.
 *
 * @return
 *  An associative array containing the XML namespace prefix as a
 *  key and the namespace URI as its value.
 */
function getDataSourceNamespaces() {
  return array('xmlns:dcterms' => 'http://purl.org/dc/terms/');
}

/**
 * Required function. Defines the 'human-readable' web page for
 * an item.
 *
 * @param string $identifier
 *  The identifier portion of the request URI.
 *
 * @param object $app
 *  The Slim $app object.
 */
function getWebPage($identifier, $app) {
  list($namespace, $alias, $pointer) = explode(':', $identifier);
  $config = dataSourceConfig($namespace);
  $url = $config['contentdm_base_url'] . $alias . '/id/' . $pointer;
  $app->redirect($url, 303);
}

/**
 * Generate the RDF XML for the item.
 *
 * Data source plugins are required to define this function
 * unless they are returning full RDF documents; in that case,
 * they must define the getResourceDataRaw() function instead.
 * See the 'static' plugin for an example.
 *
 * @param string $identifier
 *  The identifier portion of the request URI.
 *
 * @param object $xml
 *  The SimpleXML $xml object.
 *
 * @param object $app
 *  The Slim $app object.
 *
 * @return
 *  The SimpleXML $xml object.
 */
function getResourceData($identifier, $xml, $app) {
  list($namespace, $alias, $pointer) = explode(':', $identifier);
  $config = dataSourceConfig($namespace);

  // CONTENTdm nicknames for administrative fields. We don't want to return
  // these so we filter them out below.
  $admin_fields = array('fullrs', 'find', 'dmaccess', 'dmimage', 'dmcreated', 
    'dmmodified', 'dmoclcno', 'dmrecord'
  );

  // Get the collection's field configuration info, plus CONTENTdm's
  // Dublin Core configuration info. We will use these configurations
  // to filter the fields mapped to DC in the collection from the fields
  // that are not.
  $field_info = getCollectionFieldConfig($namespace, '/' . $alias);
  $dc_field_info = getDcFieldInfo($namespace);

  // This is where we query the API, which returns a JSON representation of the metadata.
  $query_url = $config['ws_url'] . 'dmGetItemInfo' . '/' . $alias . '/' .  $pointer . '/json';
  $response = file_get_contents($query_url);
  $item_info = json_decode($response, TRUE);

  // Loop through the fields in the item's metadata and replace the fieldnames
  // with their Dublin Core mappings.
  if (is_array($item_info)) {
    foreach ($item_info as $field_key => $field_value) {
      // Fields with no values are returned as empty arrays.
      if (is_string($field_value) && !in_array($field_key, $admin_fields)) {
        // Replace nicknames with DC mappings from collection configuration.
        for ($i = 0; $i < count($field_info); $i++) {
          if (isset($field_key) && $field_key == $field_info[$i]['nick']) {
            $dc = $field_info[$i]['dc'];
            if (is_string($field_value) && $dc != 'BLANK') {
              $dc_label = $dc_field_info[$dc];
              // $dc_label is blank if it wasn't mapped in getDcFieldInfo(), so skip it.
              if (strlen($dc_label)) {
                $xml->writeElementNS('dc', strtolower($dc_label), NULL, $field_value);
              }
            }
          }
        } 
      } 
    }
    return $xml;
  }
  else {
    return FALSE;
  }
}

/**
 * Function specific to this plugin.
 *
 * Gets the collection's field configuration from CONTENTdm. The collection
 * is identified by $alias.
 *
 * @param string $alias
 *  The CONTENTdm collection alias.
 *
 * @return
 *  An associative array containing the collection's field configuration
 *  settings.
 */
function getCollectionFieldConfig($namespace, $alias) {
  $config = dataSourceConfig($namespace);
  $query = $config['ws_url'] . 'dmGetCollectionFieldInfo' . $alias . '/json';
  $json = file_get_contents($query, false, NULL);
  return json_decode($json, true);
}

/**
 * Function specific to this plugin.
 *
 * Get the CONTENTdm Dublin Core field mappings.
 *
 * @return
 *  An associative array containing the collection's Dublin Core 
 *  configuration settings.
 */
function getDcFieldInfo($namespace) {
  $config = dataSourceConfig($namespace);
  $request = $config['ws_url'] . 'dmGetDublinCoreFieldInfo/json';
  $json = file_get_contents($request, false, NULL);
  $raw_dc_field_info = json_decode($json, TRUE);

  // Convert from an anonymous array to a nick => name array.
  $dc_fields = array();
  foreach ($raw_dc_field_info as $field) {
    $dc_fields[$field['nick']] = $field['name'];
  }
  return $dc_fields;
}

